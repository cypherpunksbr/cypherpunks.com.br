I"f<p>Satoshi Nakamoto
31 de outubro de 2008</p>

<hr />

<h2 id="abstract">Abstract</h2>

<p>Uma vers√£o puramente peer-to-peer do dinheiro eletr√¥nico permitiria que pagamentos on-line fossem enviados diretamente de uma parte para outra sem passar por uma institui√ß√£o financeira. Assinaturas digitais fornecem parte da solu√ß√£o, mas os principais benef√≠cios s√£o perdidos se um terceiro confi√°vel ainda for necess√°rio para evitar o gasto duplo. Propomos uma solu√ß√£o para o problema do gasto duplo usando uma rede peer-to-peer. A rede registra as transa√ß√µes de data e hora, transformando-as em uma cadeia cont√≠nua de prova de trabalho baseada em hash, formando um registro que n√£o pode ser alterado sem refazer a prova de trabalho. A cadeia mais longa n√£o serve apenas como prova da sequ√™ncia de eventos testemunhada, mas prova de que ela veio do maior conjunto de poder da CPU. Enquanto a maioria da energia da CPU √© controlada por n√≥s que n√£o est√£o cooperando para atacar a rede, eles Vai gerar os atacantes de cadeia e de sa√≠da mais longos. A rede em si requer estrutura m√≠nima. As mensagens s√£o transmitidas com base no melhor esfor√ßo, e os n√≥s podem sair e se juntar √† rede √† vontade, aceitando a mais longa cadeia de prova de trabalho como prova do que aconteceu enquanto eles estavam fora.</p>

<h2 id="1-introdu√ß√£o">1. Introdu√ß√£o</h2>

<p>O com√©rcio na Internet passou a depender quase exclusivamente de institui√ß√µes financeiras que servem como terceiros confi√°veis ‚Äã‚Äãpara processar pagamentos eletr√¥nicos. Enquanto o sistema funciona bem o suficiente para a maioria das transa√ß√µes, ele ainda sofre com as fraquezas inerentes do modelo baseado em confian√ßa. Transa√ß√µes completamente n√£o revers√≠veis n√£o s√£o realmente poss√≠veis, uma vez que as institui√ß√µes financeiras n√£o podem evitar a media√ß√£o de disputas. O custo da media√ß√£o aumenta os custos de transa√ß√£o, limitando o tamanho m√≠nimo pr√°tico da transa√ß√£o e eliminando a possibilidade de pequenas transa√ß√µes casuais, e h√° um custo mais amplo na perda da capacidade de efetuar pagamentos n√£o revers√≠veis para servi√ßos n√£o revers√≠veis. Com a possibilidade de revers√£o, a necessidade de confian√ßa se espalha. Os comerciantes devem ter cuidado com seus clientes, pedindo mais informa√ß√µes do que precisariam. Uma certa porcentagem de fraude √© aceita como inevit√°vel. Esses custos e incertezas de pagamento podem ser evitados pessoalmente usando moeda f√≠sica, mas n√£o existe nenhum mecanismo para efetuar pagamentos em um canal de comunica√ß√£o sem uma parte confi√°vel.</p>

<p>O que √© necess√°rio √© um sistema de pagamento eletr√¥nico baseado em prova criptogr√°fica em vez de confian√ßa, permitindo que duas partes interessadas negociem diretamente entre si sem a necessidade de um terceiro confi√°vel. As transa√ß√µes que s√£o computacionalmente impratic√°veis ‚Äã‚Äãde reverter protegeriam os vendedores de fraude, e mecanismos de dep√≥sito de rotina poderiam ser facilmente implementados para proteger os compradores. Neste artigo, propomos uma solu√ß√£o para o problema do gasto duplo usando um servidor de timestamp distribu√≠do peer-to-peer para gerar prova computacional da ordem cronol√≥gica das transa√ß√µes. O sistema √© seguro desde que os n√≥s honestos controlem coletivamente mais energia da CPU do que qualquer grupo colaborador de n√≥s atacantes.</p>

<h2 id="2-transa√ß√µes">2. Transa√ß√µes</h2>

<p>N√≥s definimos uma moeda eletr√¥nica como uma cadeia de assinaturas digitais. Cada propriet√°rio transfere a moeda para a pr√≥xima assinando digitalmente um hash da transa√ß√£o anterior e a chave p√∫blica do pr√≥ximo propriet√°rio e adicionando-os ao final da moeda. Um benefici√°rio pode verificar as assinaturas para verificar a cadeia de propriedade.</p>

<p><img src="https://nakamotoinstitute.org/static/img/bitcoin/transactions.svg" alt="" /></p>

<p>O problema, √© claro, √© que o benefici√°rio n√£o pode verificar se um dos donos n√£o gastou duas vezes a moeda. Uma solu√ß√£o comum √© introduzir uma autoridade central confi√°vel, que verifica todas as transa√ß√µes para gastos duplicados. Ap√≥s cada transa√ß√£o, a moeda deve ser devolvida √† casa da moeda para emitir uma nova moeda, e somente as moedas emitidas diretamente da casa da moeda s√£o confi√°veis para n√£o serem gastas duas vezes. O problema com esta solu√ß√£o √© que o destino de todo o sistema monet√°rio depende da empresa que opera a casa da moeda, com cada transa√ß√£o tendo que passar por eles, assim como um banco.</p>

<p>Precisamos de uma maneira de o benefici√°rio saber que os propriet√°rios anteriores n√£o assinaram nenhuma transa√ß√£o anterior. Para nossos prop√≥sitos, a primeira transa√ß√£o √© a que conta, por isso n√£o nos importamos com as tentativas posteriores de gastar duas vezes. A √∫nica maneira de confirmar a aus√™ncia de uma transa√ß√£o √© estar ciente de todas as transa√ß√µes. No modelo baseado em hortel√£, a casa da moeda estava ciente de todas as transa√ß√µes e decidiu qual delas chegava primeiro. Para conseguir isso sem uma parte confi√°vel, as transa√ß√µes devem ser anunciadas publicamente [1] , e precisamos de um sistema para os participantes concordarem em um √∫nico hist√≥rico da ordem em que foram recebidos. O benefici√°rio precisa comprovar que, no momento de cada transa√ß√£o, a maioria dos n√≥s concordou que foi a primeira recebida.</p>

<h2 id="3-servidor-de-registro-de-datahora">3. Servidor de registro de data/hora</h2>

<p>A solu√ß√£o que propomos come√ßa com um servidor de timestamp. Um servidor de timestamp trabalha pegando um hash de um bloco de itens a ser timestamped e publicando amplamente o hash, como em um jornal ou post Usenet<sup><a href="#fn2">[2-5]</a></sup>. O timestamp prova que os dados devem ter existido no momento, obviamente, para entrar no hash. Cada timestamp inclui o timestamp anterior em seu hash, formando uma cadeia, com cada timestamp adicional refor√ßando os anteriores.</p>

<p><img src="https://nakamotoinstitute.org/static/img/bitcoin/timestamp-server.svg" alt="" /></p>

<h2 id="4-prova-de-trabalho">4. Prova de trabalho</h2>

<p>Para implementar um servidor de timestamp distribu√≠do em uma base peer-to-peer, precisaremos usar um sistema de prova de trabalho semelhante ao Hashcash de Adam Back<sup><a href="#fn6">[6]</a></sup> , ao inv√©s de postagens de jornal ou Usenet. A prova de trabalho envolve a verifica√ß√£o de um valor que, quando com hash, como no SHA-256, o hash come√ßa com um n√∫mero de bits zero. O trabalho m√©dio necess√°rio √© exponencial no n√∫mero de bits zero requerido e pode ser verificado pela execu√ß√£o de um √∫nico hash.</p>

<p>Para nossa rede de registro de data e hora, implementamos a prova de trabalho incrementando um nonce no bloco at√© que seja encontrado um valor que forne√ßa ao hash do bloco os bits zero necess√°rios. Uma vez que o esfor√ßo da CPU tenha sido gasto para satisfazer a prova de trabalho, o bloco n√£o pode ser alterado sem refazer o trabalho. Como os blocos posteriores s√£o encadeados depois disso, o trabalho para mudar o bloco incluiria refazer todos os blocos depois dele.</p>

<p><img src="https://nakamotoinstitute.org/static/img/bitcoin/proof-of-work.svg" alt="" /></p>

<p>A prova de trabalho tamb√©m resolve o problema de determinar a representa√ß√£o na tomada de decis√£o por maioria. Se a maioria fosse baseada em um endere√ßo IP, um voto, ele poderia ser subvertido por qualquer pessoa capaz de alocar muitos IPs. Prova de trabalho √© essencialmente um CPU-um-voto. A decis√£o da maioria √© representada pela cadeia mais longa, que tem o maior esfor√ßo de prova de trabalho investido nela. Se a maioria da pot√™ncia da CPU for controlada por n√≥s honestos, a cadeia honesta crescer√° mais r√°pido e ultrapassar√° as cadeias concorrentes. Para modificar um bloco anterior, um invasor teria que refazer a prova de trabalho do bloco e todos os blocos ap√≥s ele e, em seguida, alcan√ßar e superar o trabalho dos n√≥s honestos. N√≥s mostraremos mais tarde que a probabilidade de um atacante mais lento se aproximar diminui exponencialmente √† medida que os blocos subseq√ºentes s√£o adicionados.</p>

<p>Para compensar o aumento da velocidade do hardware e o interesse vari√°vel em executar n√≥s ao longo do tempo, a dificuldade de prova de trabalho √© determinada por uma m√©dia m√≥vel visando um n√∫mero m√©dio de blocos por hora. Se eles s√£o gerados muito r√°pido, a dificuldade aumenta.</p>

<h2 id="5-rede">5. Rede</h2>

<p>As etapas para executar a rede s√£o as seguintes:</p>

<ol>
  <li>Novas transa√ß√µes s√£o transmitidas para todos os n√≥s.</li>
  <li>Cada n√≥ coleta novas transa√ß√µes em um bloco.</li>
  <li>Cada n√≥ trabalha para encontrar uma prova de trabalho dif√≠cil para o seu bloco.</li>
  <li>Quando um n√≥ encontra uma prova de trabalho, ele transmite o bloco para todos os n√≥s.</li>
  <li>Os n√≥s aceitam o bloco somente se todas as transa√ß√µes nele forem v√°lidas e j√° n√£o tiverem sido gastas.</li>
  <li>Os n√≥s expressam sua aceita√ß√£o do bloco trabalhando na cria√ß√£o do pr√≥ximo bloco da cadeia, usando o hash do bloco aceito como o hash anterior.</li>
</ol>

<p>Os n√≥s sempre consideram a cadeia mais longa a correta e continuar√£o trabalhando para estend√™-la. Se dois n√≥s transmitem vers√µes diferentes do pr√≥ximo bloco simultaneamente, alguns n√≥s podem receber um ou outro primeiro. Nesse caso, eles trabalham no primeiro que receberam, mas salvam o outro ramo no caso dele se tornar mais longo. O empate ser√° quebrado quando a pr√≥xima prova de trabalho for encontrada e uma ramifica√ß√£o ficar mais longa; os n√≥s que estavam trabalhando na outra ramifica√ß√£o passar√£o para o mais longo.</p>

<p>Novas transmiss√µes de transmiss√µes n√£o precisam necessariamente atingir todos os n√≥s. Contanto que eles atinjam muitos n√≥s, eles entrar√£o em um bloco em pouco tempo. As transmiss√µes de bloco tamb√©m s√£o tolerantes a mensagens descartadas. Se um n√≥ n√£o receber um bloco, ele o solicitar√° quando receber o pr√≥ximo bloco e perceber que perdeu um.</p>

<h2 id="6-incentivo">6. Incentivo</h2>

<p>Por conven√ß√£o, a primeira transa√ß√£o em um bloco √© uma transa√ß√£o especial que inicia uma nova moeda pertencente ao criador do bloco. Isso adiciona um incentivo para que os n√≥s suportem a rede e fornece uma maneira de distribuir moedas inicialmente em circula√ß√£o, uma vez que n√£o h√° autoridade central para emiti-las. A adi√ß√£o constante de uma constante de quantidade de novas moedas √© an√°loga aos mineradores de ouro que gastam recursos para adicionar ouro √† circula√ß√£o. No nosso caso, √© o tempo de CPU e a eletricidade que √© gasta.</p>

<p>O incentivo tamb√©m pode ser financiado com taxas de transa√ß√£o. Se o valor de sa√≠da de uma transa√ß√£o for menor que seu valor de entrada, a diferen√ßa ser√° uma taxa de transa√ß√£o que √© adicionada ao valor de incentivo do bloco que cont√©m a transa√ß√£o. Uma vez que um n√∫mero predeterminado de moedas tenha entrado em circula√ß√£o, o incentivo pode transitar inteiramente para as taxas de transa√ß√£o e ser completamente livre de infla√ß√£o.</p>

<p>O incentivo pode ajudar a encorajar os n√≥s a permanecerem honestos. Se um atacante ganancioso √© capaz de reunir mais poder de CPU do que todos os n√≥s honestos, ele teria que escolher entre us√°-lo para fraudar as pessoas, roubando seus pagamentos, ou usando-o para gerar novas moedas. Ele deveria achar mais lucrativo jogar de acordo com as regras, regras que o favorecem com mais moedas novas do que todos os demais, do que prejudicar o sistema e a validade de sua pr√≥pria riqueza.</p>

<h2 id="7-recuperando-espa√ßo-em-disco">7. Recuperando espa√ßo em disco</h2>

<p>Depois que a transa√ß√£o mais recente em uma moeda √© enterrada em blocos suficientes, as transa√ß√µes gastas antes dela podem ser descartadas para economizar espa√ßo em disco. Para facilitar isso sem quebrar o hash do bloco, as transa√ß√µes s√£o divididas em uma √°rvore Merkle <sup><a href="#fn7">[7]</a></sup><sup><a href="#fn2">[2]</a></sup><sup><a href="#fn5">[5]</a></sup> , com apenas a raiz inclu√≠da no hash do bloco. Blocos antigos podem ent√£o ser compactados arrancando galhos da √°rvore. Os hashes interiores n√£o precisam ser armazenados.</p>

<p><img src="https://nakamotoinstitute.org/static/img/bitcoin/reclaiming-disk-space.svg" alt="" /></p>

<p>Um cabe√ßalho de bloco sem transa√ß√µes seria de cerca de 80 bytes. Se supusermos que blocos s√£o gerados a cada 10 minutos, 80 bytes * 6 * 24 * 365 = 4,2 MB por ano. Com os sistemas de computador vendendo normalmente com 2 GB de RAM a partir de 2008, e a Lei de Moore prevendo um crescimento atual de 1,2 GB por ano, o armazenamento n√£o deve ser um problema, mesmo que os cabe√ßalhos dos blocos sejam mantidos na mem√≥ria.</p>

<h2 id="8-verifica√ß√£o-simplificada-de-pagamento">8. Verifica√ß√£o Simplificada de Pagamento</h2>

<p>√â poss√≠vel verificar pagamentos sem executar um n√≥ de rede completo. Um usu√°rio s√≥ precisa manter uma c√≥pia dos cabe√ßalhos de bloco da maior cadeia de prova de trabalho, o que ele pode fazer consultando os n√≥s da rede at√© convenc√™-lo de ter a cadeia mais longa e obter a ramifica√ß√£o Merkle que vincula a transa√ß√£o ao bloco Ele n√£o pode verificar a transa√ß√£o por si mesmo, mas ligando-a a um lugar na cadeia, ele pode ver que um n√≥ de rede aceitou e bloqueou adicionado depois de confirmar que a rede aceitou a transa√ß√£o.</p>

<p><img src="https://nakamotoinstitute.org/static/img/bitcoin/simplified-payment-verification.svg" alt="" /></p>

<p>Como tal, a verifica√ß√£o √© confi√°vel desde que os n√≥s honestos controlem a rede, mas seja mais vulner√°vel se a rede for dominada por um invasor. Embora os n√≥s de rede possam verificar as transa√ß√µes por conta pr√≥pria, o m√©todo simplificado pode ser enganado pelas transa√ß√µes fabricadas por um invasor enquanto o invasor puder continuar a dominar a rede. Uma estrat√©gia para proteger contra isso seria aceitar alertas de n√≥s de rede quando detectarem um bloco inv√°lido, solicitando que o software do usu√°rio baixe o bloco inteiro e alertou as transa√ß√µes para confirmar a inconsist√™ncia. As empresas que recebem pagamentos freq√ºentes provavelmente ainda precisar√£o executar seus pr√≥prios n√≥s para obter uma seguran√ßa mais independente e uma verifica√ß√£o mais r√°pida.</p>

<h2 id="9-combinando-e-dividindo-valor">9. Combinando e dividindo valor</h2>

<p>Embora fosse poss√≠vel lidar com moedas individualmente, seria dif√≠cil fazer uma transa√ß√£o separada para cada centavo em uma transfer√™ncia. Para permitir que o valor seja dividido e combinado, as transa√ß√µes cont√™m v√°rias entradas e sa√≠das. Normalmente, haver√° uma √∫nica entrada de uma transa√ß√£o anterior maior ou v√°rias entradas combinando quantidades menores e no m√°ximo duas sa√≠das: uma para o pagamento e outra retornando a altera√ß√£o, se houver, de volta ao remetente.</p>

<p><img src="https://nakamotoinstitute.org/static/img/bitcoin/combining-splitting-value.svg" alt="" /></p>

<p>Deve-se notar o espalhamento, onde uma transa√ß√£o depende de v√°rias transa√ß√µes, e essas transa√ß√µes dependem de muito mais, n√£o √© um problema aqui. Nunca h√° a necessidade de extrair uma c√≥pia aut√¥noma completa do hist√≥rico de uma transa√ß√£o.</p>

<h2 id="10-privacidade">10. Privacidade</h2>

<p>O modelo banc√°rio tradicional atinge um n√≠vel de privacidade ao limitar o acesso √† informa√ß√£o √†s partes envolvidas e ao terceiro de confian√ßa. A necessidade de anunciar todas as transa√ß√µes exclui publicamente esse m√©todo, mas a privacidade ainda pode ser mantida quebrando o fluxo de informa√ß√µes em outro lugar: mantendo as chaves p√∫blicas an√¥nimas. O p√∫blico pode ver que algu√©m est√° enviando uma quantia para outra pessoa, mas sem informa√ß√µes vinculando a transa√ß√£o a ningu√©m. Isso √© semelhante ao n√≠vel de informa√ß√µes divulgadas pelas bolsas de valores, onde o tempo e o tamanho dos neg√≥cios individuais, a ‚Äúfita‚Äù, s√£o tornados p√∫blicos, mas sem dizer quem eram as partes.</p>

<p><img src="https://nakamotoinstitute.org/static/img/bitcoin/privacy.svg" alt="" /></p>

<p>Como um firewall adicional, um novo par de chaves deve ser usado para cada transa√ß√£o para impedir que elas sejam vinculadas a um propriet√°rio comum. Algumas liga√ß√µes ainda s√£o inevit√°veis ‚Äã‚Äãcom transa√ß√µes com m√∫ltiplos inputs, que necessariamente revelam que suas entradas eram de propriedade do mesmo propriet√°rio. O risco √© que, se o propriet√°rio de uma chave for revelado, a vincula√ß√£o poder√° revelar outras transa√ß√µes pertencentes ao mesmo propriet√°rio.</p>

<h2 id="11-c√°lculos">11. C√°lculos</h2>

<p>Consideramos o cen√°rio de um invasor tentando gerar uma cadeia alternativa mais rapidamente que a cadeia honesta. Mesmo que isso seja feito, ele n√£o abre o sistema para mudan√ßas arbitr√°rias, como a cria√ß√£o de valor a partir do nada ou a obten√ß√£o de dinheiro que nunca pertenceu ao invasor. Os n√≥s n√£o aceitar√£o uma transa√ß√£o inv√°lida como pagamento e os n√≥s honestos nunca aceitar√£o um bloco que os contenha. Um invasor s√≥ pode tentar alterar uma de suas transa√ß√µes para receber o dinheiro que gastou recentemente.</p>

<p>A corrida entre a cadeia honesta e uma cadeia atacante pode ser caracterizada como uma Caminhada Aleat√≥ria Binomial. O evento de sucesso √© a cadeia honesta sendo estendida por um bloco, aumentando sua lideran√ßa em +1, e o evento de falha √© a cadeia do atacante sendo estendida por um bloco, reduzindo o intervalo em -1.</p>

<p>A probabilidade de um atacante se recuperar de um dado d√©ficit √© an√°loga ao problema da Ru√≠na do Jogador. Suponha que um jogador com cr√©dito ilimitado comece com um d√©ficit e jogue potencialmente um n√∫mero infinito de tentativas para tentar alcan√ßar o ponto de equil√≠brio. Podemos calcular a probabilidade de ele chegar ao ponto de equil√≠brio, ou de que um atacante alcan√ßa a cadeia honesta, como segue [8] :</p>

\[\begin{eqnarray*}
\large p &amp;=&amp; \text{probabilidade de um n√≥ honesto encontrar o pr√≥ximo bloco} \\
\large q &amp;=&amp; \text{probabilidade de um atacante encontrar o pr√≥ximo bloco}\\
\large q_z &amp;=&amp; \text{probabilidade que o atacante ir√° recuperar $z$ blocos}
\end{eqnarray*}\]

\[\large q_z = \begin{Bmatrix}
1 &amp; \textit{if}\; p \leq q\\
(q/p)^z &amp; \textit{if}\; p &gt; q
\end{Bmatrix}\]

<p>Considerando nossa suposi√ß√£o de que $p \gt q$, a probabilidade cai exponencialmente √† medida que o n√∫mero de bloqueios que o invasor tem para alcan√ßar aumenta. Com as probabilidades contra ele, se ele n√£o der um golpe de sorte para a frente logo no in√≠cio, suas chances se tornam cada vez menores, j√° que ele fica ainda mais para tr√°s.</p>

<p>Consideramos agora quanto tempo o destinat√°rio de uma nova transa√ß√£o precisa esperar antes de ter certeza de que o remetente n√£o pode alterar a transa√ß√£o. Assumimos que o remetente √© um invasor que quer fazer com que o destinat√°rio acredite que ele o pagou por um tempo, depois o substitui para pagar a si mesmo ap√≥s algum tempo. O receptor ser√° alertado quando isso acontecer, mas o remetente espera que seja tarde demais.</p>

<p>O receptor gera um novo par de chaves e fornece a chave p√∫blica ao remetente logo antes de assinar. Isso evita que o remetente prepare uma cadeia de blocos com anteced√™ncia, trabalhando nela continuamente at√© que tenha a sorte de chegar longe o suficiente e depois executar a transa√ß√£o naquele momento. Depois que a transa√ß√£o √© enviada, o remetente desonesto come√ßa a trabalhar em segredo em uma cadeia paralela contendo uma vers√£o alternativa de sua transa√ß√£o.</p>

<p>O destinat√°rio aguarda at√© que a transa√ß√£o seja adicionada a um bloco e $z$ blocos foram ligados depois. Ele n√£o sabe a quantidade exata de progresso que o invasor fez, mas supondo que os blocos honestos tenham demorado o tempo m√©dio esperado por bloco, o progresso potencial do atacante ser√° uma distribui√ß√£o de Poisson com o valor esperado:</p>

<p>$\large \lambda = z \frac qp$</p>

<p>Para obter a probabilidade que o atacante ainda pode alcan√ßar agora, multiplicamos a densidade de Poisson para cada quantidade de progresso que ele poderia ter feito pela probabilidade que ele poderia alcan√ßar a partir desse ponto:</p>

<p>$\large \sum_{k=0}^{\infty} \frac{\lambda^k e^{-\lambda}}{k!} \cdot \begin{Bmatrix} (q/p)^{(z-k)} &amp; \textit{if}\;k\leq z\ 1 &amp; \textit{if} \; k &gt; z \end{Bmatrix}$</p>

<p>Reorganizando para evitar somar a cauda infinita da distribui√ß√£o ‚Ä¶</p>

<p>$\large 1 - \sum_{k=0}^{z} \frac{\lambda^k e^{-\lambda}}{k!} \left ( 1-(q/p)^{(z-k)} \right )$</p>

<p>Convertendo em c√≥digo C‚Ä¶</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include double AttackerSuccessProbability(double q, int z)
{
	double p = 1.0 - q;
	double lambda = z * (q / p);
	double sum = 1.0;
	int i, k;
	for (k = 0; k &lt;= z; k++)
	{
		double poisson = exp(-lambda);
		for (i = 1; i &lt;= k; i++)
			poisson *= lambda / i;
		sum -= poisson * (1 - pow(q / p, z - k));
	}
	return sum;
}
</code></pre></div></div>

<p>Depois de alguns resultados, podemos ver a probabilidade cair exponencialmente com $z$.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q=0.1
z=0    P=1.0000000
z=1    P=0.2045873
z=2    P=0.0509779
z=3    P=0.0131722
z=4    P=0.0034552
z=5    P=0.0009137
z=6    P=0.0002428
z=7    P=0.0000647
z=8    P=0.0000173
z=9    P=0.0000046
z=10   P=0.0000012
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q=0.3
z=0    P=1.0000000
z=5    P=0.1773523
z=10   P=0.0416605
z=15   P=0.0101008
z=20   P=0.0024804
z=25   P=0.0006132
z=30   P=0.0001522
z=35   P=0.0000379
z=40   P=0.0000095
z=45   P=0.0000024
z=50   P=0.0000006
</code></pre></div></div>

<p>Resolvendo para P menores que 0.1%‚Ä¶</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P &lt; 0.001
q=0.10   z=5
q=0.15   z=8
q=0.20   z=11
q=0.25   z=15
q=0.30   z=24
q=0.35   z=41
q=0.40   z=89
q=0.45   z=340
</code></pre></div></div>

<h2 id="12-conclus√£o">12. Conclus√£o</h2>

<p>Propusemos um sistema para transa√ß√µes eletr√¥nicas sem depender da confian√ßa. Come√ßamos com a estrutura usual de moedas feitas a partir de assinaturas digitais, que fornece um forte controle de propriedade, mas √© incompleta sem uma maneira de evitar o gasto duplo. Para resolver isso, propusemos uma rede peer-to-peer usando prova de trabalho para registrar um hist√≥rico p√∫blico de transa√ß√µes que rapidamente se torna impratic√°vel para um invasor mudar se os n√≥s honestos controlarem a maior parte da energia da CPU. A rede √© robusta em sua simplicidade n√£o estruturada. Os n√≥s trabalham todos de uma vez com pouca coordena√ß√£o. Eles n√£o precisam ser identificados, pois as mensagens n√£o s√£o roteadas para nenhum lugar espec√≠fico e precisam ser entregues apenas com base no melhor esfor√ßo. Os n√≥s podem sair e se juntar √† rede √† vontade, aceitando a cadeia de prova de trabalho como prova do que aconteceu enquanto estiveram fora. Eles votam com seu poder de CPU, expressando sua aceita√ß√£o de blocos v√°lidos trabalhando em estend√™-los e rejeitando blocos inv√°lidos, recusando-se a trabalhar neles. Quaisquer regras e incentivos necess√°rios podem ser aplicados com este mecanismo de consenso.</p>

<h2 id="refer√™ncias">Refer√™ncias</h2>

<ol>
  <li>
    <p>W. Dai, <a href="http://nakamotoinstitute.org/b-money/">‚Äúb-money,‚Äù</a> <a href="http://www.weidai.com/bmoney.txt">http://www.weidai.com/bmoney.txt</a>, 1998.¬†<a href="#ref1" title="Jump back to [1]">‚Ü©</a></p>
  </li>
  <li>
    <p>H. Massias, X.S. Avila, and J.-J. Quisquater, <a href="http://nakamotoinstitute.org/secure-timestamping-service.pdf">‚ÄúDesign of a secure timestamping service with minimal trust requirements,‚Äù</a> In <em>20th Symposium on Information Theory in the Benelux</em>, May 1999.¬†<a href="#ref2" title="Jump back to [2-5]">‚Ü©</a>¬†<a href="#ref2-2" title="Jump back to [2]">‚Ü©</a></p>
  </li>
  <li>
    <p>S. Haber, W.S. Stornetta, <a href="http://nakamotoinstitute.org/time-stamp-digital-document.pdf">‚ÄúHow to time-stamp a digital document,‚Äù</a> In <em>Journal of Cryptology</em>, vol 3, no 2, pages 99-111, 1991.¬†<a href="#ref2" title="Jump back to [2-5]">‚Ü©</a></p>
  </li>
  <li>
    <p>D. Bayer, S. Haber, W.S. Stornetta, <a href="http://nakamotoinstitute.org/improving-time-stamping.pdf">‚ÄúImproving the efficiency and reliability of digital time-stamping,‚Äù</a> In <em>Sequences II: Methods in Communication, Security and Computer Science</em>, pages 329-334, 1993.¬†<a href="#ref2" title="Jump back to [2-5]">‚Ü©</a></p>
  </li>
  <li>
    <p>S. Haber, W.S. Stornetta, <a href="http://nakamotoinstitute.org/secure-names-bit-strings.pdf">‚ÄúSecure names for bit-strings,‚Äù</a> In <em>Proceedings of the 4th ACM Conference on Computer and Communications Security</em>, pages 28-35, April 1997.¬†<a href="#ref2" title="Jump back to [2-5]">‚Ü©</a>¬†<a href="#ref5" title="Jump back to [5]">‚Ü©</a></p>
  </li>
  <li>
    <p>A. Back, <a href="http://nakamotoinstitute.org/hashcash.pdf">‚ÄúHashcash - a denial of service counter-measure,‚Äù</a> <a href="http://www.hashcash.org/papers/hashcash.pdf">http://www.hashcash.org/papers/hashcash.pdf</a>, 2002.¬†<a href="#ref6" title="Jump back to [6]">‚Ü©</a></p>
  </li>
  <li>
    <p>R.C. Merkle, <a href="http://nakamotoinstitute.org/public-key-cryptosystems.pdf">‚ÄúProtocols for public key cryptosystems,‚Äù</a> In <em>Proc. 1980 Symposium on Security and Privacy</em>, IEEE Computer Society, pages 122-133, April 1980.¬†<a href="#ref7" title="Jump back to [7]">‚Ü©</a></p>
  </li>
  <li>
    <p>W. Feller, <a href="http://nakamotoinstitute.org/introduction-probability-theory-vol-i.pdf">‚ÄúAn introduction to probability theory and its applications,‚Äù</a> 1957.¬†<a href="#ref8" title="Jump back to [8]">‚Ü©</a></p>
  </li>
</ol>
:ET